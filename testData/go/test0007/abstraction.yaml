{
  language: go,
  abstracts: [
    { exported: true, name: $deref, signature: 2 }, # 1. func $deref() Foo[string|int]
    { exported: true, name: $deref, signature: 3 }, # 2. func $deref() T <any>
    { exported: true, name: Add,    signature: 4 }, # 3. func Add(v string) string
    { exported: true, name: Add,    signature: 7 }, # 4. func Add(v T) T <string|int>
    { exported: true, name: Add,    signature: 8 }  # 5. func Add(v T) T <string|int|uint>
  ],
  arguments: [
    { type: basic3 },              #  1. <unnamed> string
    { type: interfaceDecl1 },      #  2. <unnamed> Pointer[T <any>] ???
    { type: interfaceInst1 },      #  3. <unnamed> Pointer[Foo[T <string|int>]]
    { type: objectInst2 },         #  4. <unnamed> Foo[T <string|int>]
    { type: typeParam1 },          #  5. <unnamed> T <any>
    { type: typeParam2 },          #  6. <unnamed> T <string|int>
    { type: typeParam3 },          #  7. <unnamed> T <string|int|uint>
    { name: v, type: basic3 },     #  8. v string
    { name: v, type: typeParam2 }, #  9. v T <string|int>
    { name: v, type: typeParam3 }  # 10. v T <string|int|uint>
  ],
  basics: [ int, uint, string ],
  fields: [
    { name: value, type: basic3 },     # 1. value string
    { name: value, type: typeParam2 }, # 2. value T <string|int>
    { name: value, type: typeParam3 }  # 3. value T <string|int|uint>
  ],
  interfaceDecls: [
    { # 1. Pointer[T any] { $deref() T <any> }
      name: Pointer, package: 1, interface: 5, exported: true,
      instances: [ 1 ], typeParams: [ 1 ]
    },
    { # 2. any
      name: any, package: 1, interface: 1, exported: true
    }
  ],
  interfaceDescs: [
    {}, # 1. any
    {   # 2. string|int
      exact: [ basic3, basic1 ],
      # Inherits 3 because 2 is more restrictive and can be used anywhere 3 can be,
      # but 3 can't be used anywhere 2 can be since 3 might be an uint instance.
      inherits: [ 3 ]
    },
    { # 3. string|int|uint
      exact: [ basic3, basic1, basic2 ], inherits: [ 1 ]
    },
    { # 4. interface { $deref() Foo[string|int] }
      abstracts: [ 1 ], inherits: [ 1 ]
    },
    { # 5. interface { $deref() T <any> }
      abstracts: [ 2 ], inherits: [ 1 ]
    },
    { # 6. interface { Add(v string) string }
      abstracts: [ 3 ], inherits: [ 1 ]
    },
    { # 7. interface { Add(v T) T <string|int> }
      abstracts: [ 4 ], inherits: [ 1 ]
    },
    { # 8. interface { Add(v T) T <string|int|uint> }
      abstracts: [ 5 ], inherits: [ 1 ]
    }
  ],
  interfaceInsts: [
    { # 1. Pointer[Foo[string|int]] { $deref() Foo[string|int] }
      generic: 1, resolved: 4,
      instanceTypes: [ objectInst2 ]
    }
  ],
  methods: [
    { # 1. func (Foo[T string|int|uint]) Add(v T) T
      name: Add, package: 2, signature: 8, exported: true,
      receiver: 1, loc: 9, metrics: 1,
      instances: [ 1, 3 ],
    },
    { # 2. func New(v T <sting|int>) Pointer[Foo[T]]
      name: New, package: 2, signature: 6, exported: true,
      loc: 14, metrics: 2,
      instances: [ 2 ], typeParams: [ 2 ]
    },
    { # 3. func main()
      name: main, package: 2, signature: 1,
      loc: 18, metrics: 3
    }
  ],
  methodInsts: [
    { # 1. func (Foo[string]) Add(v string) string
      generic: 1, receiver: 1, resolved: 4,
      instanceTypes: [ basic3 ]
    },
    { # 2. func New(v sting) Pointer[T <any>] ???
      generic: 2, resolved: 5,
      instanceTypes: [ basic3 ]
    },
    { # 3. func (Foo[T <string|int>]) Add(v T) T
      generic: 1, receiver: 2, resolved: 7,
      instanceTypes: [ typeParam2 ]
    }
  ],
  metrics: [
    { # 1. Foo.Add metrics
      codeCount: 4, complexity: 1, indents: 2, lineCount: 4, loc: 9,
      reads:  [ object1, selection3 ],
      writes: [ selection3 ]
    },
    { # 2. New metrics
      codeCount: 3, complexity: 1, indents: 1, lineCount: 3, loc: 14,
      reads:  [ objectInst2 ],
      writes: [ objectInst2, selection2 ]
    },
    { # 3. main metrics
      codeCount: 4, complexity: 1, indents: 2, lineCount: 4, loc: 18,
      invokes: [ methodInst2, selection1 ],
      reads:   [ objectInst1 ],
      writes:  [ objectInst1 ]
    }
  ],
  objectInsts: [
    { # 1. main.Foo[string]{ value string }{ Add(v string) string }
      generic: 1, resData: 1, resInterface: 6,
      instanceTypes: [ basic3 ], methods: [ 1 ]
    },
    { # 2. main.Foo[T string|int]{ value T }{ Add(v T) T }
      generic: 1, resData: 2, resInterface: 7,
      instanceTypes: [ typeParam2 ], methods: [ 3 ]
    }
  ],
  objects: [
    { # 1. main.Foo[T string|int|uint]{ value T }{ Add(v T) T }
      loc: 5, name: Foo, package: 2,
      exported: true, data: 3, interface: 8,
      instances:  [ 1, 2 ],
      methods:    [ 1 ],
      typeParams: [ 3 ]
    }
  ],
  packages: [
    { # 1. $builtin package
      name: $builtin,
      path: $builtin,
      interfaces: [ 1, 2 ]
    },
    { # 2. main package
      name: main,
      path: command-line-arguments,
      methods: [ 1, 2, 3 ],
      objects: [ 1 ]
    }
  ],
  selections: [
    { name: Add,   origin: objectInst1 }, # 1. Foo[string].Add
    { name: value, origin: objectInst2 }, # 2. Foo[string|int].value
    { name: value, origin: object1 }      # 3. Foo[string|int|uint].value
  ],
  signatures: [
    {},                                 # 1. func()()
    {                 results: [ 4 ] }, # 2. func() Foo[string|int]
    {                 results: [ 5 ] }, # 3. func() T <any>
    { params: [  8 ], results: [ 1 ] }, # 4. func(v string) string
    # TODO: Why does 5 use result 2 instead of `Pointer[Foo[string]]`?
    { params: [  8 ], results: [ 2 ] }, # 5. func(v string) Pointer[T <any>] ???
    { params: [  9 ], results: [ 3 ] }, # 6. func(v T <string|int>) Pointer[Foo[T]]
    { params: [  9 ], results: [ 6 ] }, # 7. func(v T) T <string|int>
    { params: [ 10 ], results: [ 7 ] }  # 8. func(v T) T <string|int|uint>
  ],
  structDescs: [
    { fields: [ 1 ] }, # 1. struct { value string }
    { fields: [ 2 ] }, # 2. struct { value T <string|int> }
    { fields: [ 3 ] }  # 3. struct { value T <string|int|uint> }
  ],
  typeParams: [
    { name: T, type: interfaceDecl2 }, # 1. T any
    { name: T, type: interfaceDesc2 }, # 2. T string|int
    { name: T, type: interfaceDesc3 }  # 3. T string|int|uint
  ],
  locs: {
    '1': main.go
  }
}
