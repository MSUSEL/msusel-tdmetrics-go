{
  language: go,
  abstracts: [
    { vis: exported, name: $deref, signature: 3 }, # 1. $deref() nodeImp
    { vis: exported, name: $deref, signature: 4 }, # 2. $deref() T <any>
    { vis: exported, name: $equal, signature: 6 }, # 3. $equal(other any) bool
    { vis: exported, name: Next,   signature: 2 }, # 4. Next() Pointer[nodeImp]
    { vis: exported, name: Next,   signature: 4 }, # 5. Next() T <any>
    { vis: exported, name: Next,   signature: 5 }, # 6. Next() T <interface{ $equal(other any) bool; Next() T }>
  ],
  arguments: [
    {              type: basic1 },         # 1. <unnamed> bool
    {              type: basic2 },         # 2. <unnamed> int
    {              type: interfaceInst1 }, # 3. <unnamed> Pointer[nodeImp]
    {              type: object1 },        # 4. <unnamed> nodeImp
    {              type: typeParam1 },     # 5. <unnamed> T <any>
    {              type: typeParam2 },     # 6. <unnamed> T <interface{ $equal(other any) bool; Next() T }>
    { name: other, type: interfaceDesc1 }, # 7. other any
    { name: start, type: typeParam2 },     # 8. start T <interface{ $equal(other any) bool; Next() T }>
    { name: stop,  type: typeParam2 },     # 9. stop T <interface{ $equal(other any) bool; Next() T }>
  ],
  basics: [ bool, int ],
  fields: [
    { name: next, type: interfaceInst1 } # 1. next Pointer[nodeImp]
  ],
  interfaceDecls: [
    { # 1. Pointer[T any]{ $deref() T }
      name: Pointer, package: 1, interface: 3,
      vis: exported,
      typeParams: [ 1 ],
      instances:  [ 1 ]
    },
    { # 2. comparable { $equal(other any) bool }
      name: comparable, package: 1, interface: 4,
      vis: exported
    },
    { # 3. Node[T any]
      name: Node, package: 2, interface: 5,
      vis: exported, loc: 5,
      typeParams: [ 1 ],
      instances:  [ 2 ]
    }
  ],
  interfaceDescs: [
    {}, # 1. any
    {   # 2. interface{ $deref() nodeImp; Next() Pointer[nodeImp] }
      abstracts: [ 1, 4 ], inherits: [ 3 ], hint: pointer
    },
    { # 3. interface{ $deref() T <any> }
      abstracts: [ 2 ], inherits: [ 1 ], hint: pointer
    },
    { # 4. interface{ $equal(other any) bool }
      abstracts: [ 3 ], inherits: [ 1 ], hint: comparable
    },
    { # 5. interface{ $equal(other any) bool; Next() T <any> }
      abstracts: [ 3, 5 ], inherits: [ 1 ], hint: comparable
    },
    { # 6. interface{ $equal(other any) bool; Next() T <<self>> }
      abstracts: [ 3, 6 ], inherits: [ 1 ], hint: comparable
    },
  ],
  interfaceInsts: [
    { # 1. Pointer[nodeImp]{ $deref() nodeImp }
      generic: 1, instanceTypes: [ object1 ], resolved: 2
    },
    { # 2. Node[T <interface{ $equal(other any) bool; Next() T }> ]
      generic: 3, instanceTypes: [ typeParam2 ], resolved: 6
    }
  ],
  methodInsts: [
    { # 1. func Len[Pointer[nodeImp]](start Pointer[nodeImp], stop Pointer[nodeImp]) int
      generic: 1, resolved: 7, metrics: 1,
      instanceTypes: [ interfaceInst1 ]
    }
  ],
  methods: [
    { # 1. func Len[T Node[T <interface{ $equal(other any) bool; Next() T }> ]](start T, stop T) int
      name: Len, package: 2, signature: 7,
      typeParams: [ 3 ],
      vis: exported, loc: 10, metrics: 1,
      instances: [ 1 ]
    },
    { # 2. func (nodeImp) Next() Pointer[nodeImp]
      name: Next, package: 2, receiver: 1, signature: 2,
      vis: exported, loc: 22, metrics: 2, ptrRecv: true
    },
    { # 3. func main()
      name: main, package: 2, signature: 1,
      loc: 26, metrics: 3
    }
  ],
  metrics: [
    { # 1. Len[T Node[T]] metrics
      loc: 10,
      codeCount:  7,
      complexity: 2,
      indents:    6,
      lineCount:  7,
      invokes: [ selection1 ],     # Node[T].Next() T
      reads:   [ interfaceInst2 ], # Node[T]
      writes:  [ interfaceInst2 ], # Node[T]
    },
    { # 2. nodeImp.Next metrics
      loc: 22,
      codeCount:  3,
      complexity: 1,
      indents:    1,
      lineCount:  3,
      getter: true,
      reads: [ interfaceInst1 ] # Pointer[nodeImp]
    },
    { # 3. main metrics
      loc: 26,
      codeCount:  4,
      complexity: 1,
      indents:    2,
      lineCount:  4,
      sideEffect: true,
      invokes: [ methodInst1 ], # Len[Pointer[nodeImp]](start, stop) int
      reads: [
        interfaceInst1,         # Pointer[nodeImp]
        object1,                # nodeImp
      ],
      writes: [
        interfaceInst1,         # Pointer[nodeImp]
        object1,                # nodeImp
        selection2,             # nodeImp.next
      ]
    }
  ],
  objects: [
    { # 1. nodeImp struct{ next Pointer[nodeImp] }
      name: nodeImp, package: 2, data: 1, interface: 1, loc: 18,
      methods: [ 2 ]
    }
  ],
  packages: [
    { # 1. $builtin package
      name: $builtin, path: $builtin,
      interfaces: [ 1, 2 ]
    },
    { # 2. main package
      name: main, path: command-line-arguments,
      interfaces: [ 3 ],
      methods:    [ 1, 2, 3 ],
      objects:    [ 1 ]
    }
  ],
  selections: [
    { name: Next, origin: interfaceInst2 }, # 1. Node[T <interface{comparable; Next() T}].Next() T
    { name: next, origin: object1 }         # 2. nodeImp.next T
  ],
  signatures: [
    {},                                   # 1. func()()
    {                   results: [ 3 ] }, # 2. func() Pointer[nodeImp]
    {                   results: [ 4 ] }, # 3. func() nodeImp
    {                   results: [ 5 ] }, # 4. func() T <any>
    {                   results: [ 6 ] }, # 5. func() T <interface{ $equal(other any) bool; Next() T }>
    { params: [ 7 ],    results: [ 1 ] }, # 6. func(other any) bool
    { params: [ 8, 9 ], results: [ 2 ] }, # 7. func(start T <interface{ $equal(other any) bool; Next() T }>, stop T) int
  ],
  structDescs: [
    { fields: [ 1 ] } # 1. struct{ next Pointer[nodeImp] }
  ],
  typeParams: [
    { name: T, type: interfaceDesc1 }, # 1. T any
    { name: T, type: interfaceDesc6 }, # 2. T interface{ $equal(other any) bool; Next() T }
    { name: T, type: interfaceInst2 }  # 3. T Node[T]
  ],
  locs: {
    '1': main.go
  }
}
